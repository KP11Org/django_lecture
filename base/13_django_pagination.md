### Лекция: Pagination (Постраничная навигация) в Django

---

#### **Введение в постраничную навигацию**
Постраничная навигация - это процесс разделения больших наборов данных на более мелкие, управляемые фрагменты (страницы) для улучшения взаимодействия с пользователем и производительности. В Django разбивка на страницы выполняется с помощью модуля `django.core.paginator`, который предоставляет инструменты для разделения наборов запросов на страницы и создания элементов управления навигацией.

---

### **Ключевые компоненты**
1. **Класс Paginator**  
   - Разбивает набор запросов/список на объекты `Page`.  
   - Ключевые параметры:  
     - `object_list`: набор запросов/список, который нужно разбивать на страницы.  
     - `per_page`: количество элементов на странице.  
     - `orphans` (необязательно): минимальное количество элементов, разрешенных на последней странице.  

   ```python
   from django.core.paginator import Paginator

   queryset = Post.objects.all()
   paginator = Paginator(queryset, per_page=10)  # 10 items per page
   ```

2. **Класс Page**  
   - Представляет отдельную страницу результатов.  
   - Методы/атрибуты:  
     - `page.object_list`: Элементы на текущей странице.  
     - `page.has_previous()`: Проверяет, есть ли предыдущая страница.  
     - `page.has_next()`: Проверяет, есть ли следующая страница.  
     - `page.previous_page_number()`: Возвращает номер предыдущей страницы.  
     - `page.next_page_number()`: Возвращает номер следующей страницы.  

---

### **Реализация разбивки на страницы в представлениях**
1. **Извлеките номер страницы из запроса**  
   Используйте `request.GET.get('page')`, чтобы получить номер текущей страницы.  

2. **Создайте экземпляр Paginator**  
   Передайте значение queryset и `per_page`.  

3. **Обрабатывайте недопустимые страницы**  
   Используйте блоки `try-except` для отслеживания ошибок `EmptyPage` или `PageNotAnInteger`.  

   ```python
   from django.core.paginator import Paginator, EmptyPage, PageNotAnInteger

   def post_list(request):
       post_list = Post.objects.all()
       paginator = Paginator(post_list, 10)  # 10 posts per page

       page = request.GET.get('page')
       try:
           posts = paginator.page(page)
       except PageNotAnInteger:
           posts = paginator.page(1)  # Default to first page
       except EmptyPage:
           posts = paginator.page(paginator.num_pages)  # Last page

       return render(request, 'blog/post_list.html', {'posts': posts})
   ```

---

### **Отображение разбивки на страницы в шаблонах**
1. **Отображение текущих элементов страницы**  
   Цикл по `posts.object_list` (или просто `posts` в шаблонах).  

   ```django
   {% for post in posts %}
       <h2>{{ post.title }}</h2>
       <p>{{ post.content }}</p>
   {% endfor %}
   ```

2. **Добавьте элементы управления навигацией**  
   Используйте `has_previous`, `has_next` и номера страниц.  

   ```django
   <div class="pagination">
       <span class="step-links">
           {% if posts.has_previous %}
               <a href="?page=1">&laquo; First</a>
               <a href="?page={{ posts.previous_page_number }}">Previous</a>
           {% endif %}

           <span class="current">
               Page {{ posts.number }} of {{ posts.paginator.num_pages }}.
           </span>

           {% if posts.has_next %}
               <a href="?page={{ posts.next_page_number }}">Next</a>
               <a href="?page={{ posts.paginator.num_pages }}">Last &raquo;</a>
           {% endif %}
       </span>
   </div>
   ```

3. **Стилизация под Bootstrap (необязательно)**  
   Используйте классы Bootstrap для улучшения пользовательского интерфейса:  

   ```django
   <nav aria-label="Page navigation">
       <ul class="pagination">
           {% if posts.has_previous %}
               <li class="page-item">
                   <a class="page-link" href="?page=1">&laquo; First</a>
               </li>
               <li class="page-item">
                   <a class="page-link" href="?page={{ posts.previous_page_number }}">Previous</a>
               </li>
           {% endif %}

           <li class="page-item disabled">
               <span class="page-link">
                   Page {{ posts.number }} of {{ posts.paginator.num_pages }}
               </span>
           </li>

           {% if posts.has_next %}
               <li class="page-item">
                   <a class="page-link" href="?page={{ posts.next_page_number }}">Next</a>
               </li>
               <li class="page-item">
                   <a class="page-link" href="?page={{ posts.paginator.num_pages }}">Last &raquo;</a>
               </li>
           {% endif %}
       </ul>
   </nav>
   ```

---

### **Распространенные варианты использования**
1. **Списки записей в блоге**  
   Разбейте длинные списки статей на страницы.  

2. **Результаты поиска**  
   Разбивка результатов поиска на страницы, отфильтрованных поисковым запросом.  

3. **Интерфейс администратора**  
   Администратор Django по умолчанию использует разбивку на страницы.  

4. **API**  
   Используйте разбиение на страницы в Django REST Framework с помощью "PageNumberPagination" или "LimitOffsetPagination".  

---

### **Рекомендации по разбиению на страницы**
1. **Оптимизируйте запросы**  
   Используйте `select_related()` или `prefetch_related()`, чтобы уменьшить количество обращений к базе данных.  

2. **Используйте представления на основе классов**  
   Упростите разбивку на страницы с помощью `ListView` в Django:  

   ```python
   from django.views.generic import ListView

   class PostListView(ListView):
       model = Post
       template_name = 'blog/post_list.html'
       context_object_name = 'posts'
       paginate_by = 10  # Automatically paginates!
   ```

3. **Обработка крайних случаев**  
   - Проверка значений `per_page` (например, ограничение максимального количества элементов на странице).  
   - Добавление фильтров / упорядочение просмотров с разбивкой по страницам.  

---

### **Соображения по производительности**
- Избегайте разбивки на страницы неиндексированных наборов запросов (это может замедлить выполнение запросов).  
- Используйте кэширование для часто посещаемых страниц (например, `django-redis`).  
- Для больших наборов данных рекомендуется разбиение на страницы с помощью cursor-based pagination  (например, в API).  

---

### **Краткое описание**
Инструменты разбиения на страницы в Django позволяют легко разбивать данные на страницы, сохраняя при этом производительность и удобство использования. Объединив класс `Paginator` с логикой шаблона, вы можете создать удобную навигацию для пользователей.  

**Читать далее**  
- [Документация по разбивке на страницы в Django](https://docs.djangoproject.com/en/4.2/topics/pagination/)  

---

### Домашнее задание: Pagination в Django

---

#### **Цель**
Цель этого задания — помочь вам понять и реализовать разбиение на страницы в Django. Вы попрактикуетесь в использовании класса `Paginator` в Django, создадите представления с разбиением на страницы и отобразите элементы управления разбиением на страницы в шаблонах.

---

### **Часть 1: Базовая разбивка на страницы**

1. **Создайте проект Django**
   - Создайте новый проект Django под названием `PaginationProject`.
   - Создайте приложение под названием `blog` внутри проекта.

2. **Создайте модель**
   - Определите модель `Post` в `models.py` со следующими полями:
     - `title` (поле CharField)
     - `content` (поле TextField)
     - `created_at` (поле DateTimeField, auto_now_add=True)
   - Запустите миграцию и создайте не менее 20 фиктивных постов с помощью администратора Django. 

3. **Создайте представление с разбивкой на страницы** 
   - В файле `views.py` создайте функцию представления с именем `post_list`, которая разбивает набор запросов `Post` на страницы по 5 постов на каждой. 
   - Используйте класс `Paginator` Django для обработки разбивки на страницы. 
   - Обрабатывайте крайние случаи (например, неверные номера страниц) с помощью блоков `try-except`. 

4. **Отображение разбивки на страницы в шаблоне** 
   - Создайте шаблон с именем `post_list.html`, в котором отображаются посты с разбивкой на страницы. 
   - Добавьте элементы управления навигацией (например, кнопки «Предыдущий» и «Следующий») с помощью атрибутов `has_previous`, `has_next`, `previous_page_number` и `next_page_number`.

---

### **Часть 2: Расширенная разбивка на страницы**

1. **Добавьте ссылки на номера страниц**
   - Измените шаблон `post_list.html`, чтобы отображать номера страниц (например, 1, 2, 3, ...) между кнопками «Предыдущая» и «Следующая».
   - Используйте цикл для динамического отображения номеров страниц.

2. **Стилизация с помощью Bootstrap**
   - Используйте компонент разбивки на страницы Bootstrap для стилизации элементов управления навигацией.
   - Убедитесь, что текущая страница выделена (например, с помощью класса `active`).

3. **Пагинация на основе классов**
   - Замените функцию просмотра `post_list` на представление на основе классов (`ListView`).
   - Используйте атрибут `paginate_by`, чтобы указать 5 постов на странице.
   - Убедитесь, что шаблон и элементы управления навигацией работают должным образом.

4. **Поиск и разбиение на страницы**
   - Добавьте в шаблон `post_list.html` форму поиска, которая позволит пользователям фильтровать посты по заголовку.
   - Измените представление, чтобы оно обрабатывало поисковый запрос и разбивало отфильтрованные результаты на страницы.

---

### **Часть 3: Бонус**

1. **Пагинация с помощью AJAX**
   - Реализуйте функцию «Загрузить ещё» с помощью AJAX.
   - Когда пользователь нажимает «Загрузить ещё», загрузите следующую страницу постов и добавьте их в текущий список без перезагрузки страницы.

2. **Пользовательская логика пагинации**
   - Создайте пользовательский шаблонный тег пагинации, который генерирует элементы управления пагинацией.
   - Используйте тег в вашем шаблоне "post_list.html`.

---

### **Рекомендации по отправке**  
- Загрузите в репозиторий на GitHub с:  
  - Проектом на Django, в котором реализованы все части домашней работы.  
  - `README.md`, скриншоты вашего результата.  
